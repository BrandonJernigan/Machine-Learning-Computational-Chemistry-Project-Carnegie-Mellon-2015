# Overview

Work by individual students participating in the projects was carried out in separate branches. Select "Branches" from above and click on individual student branches for both the code and results generated by the participants. 

This project uses machine learning to predict the properties of molecules. The approach attempts to use a quantum-chemical Hamiltonian as a key portion of the model form. This is in contrast to methods, such as those based on the Coulomb matrix, that attempt to predict molecular properties from features without ever needing to set up and solve a quantum-chemical model. 

It seems likely that the approach must be fragment-based, such that the model can be trained on a small subset of molecules (assembled from these fragments), and then used on any molecule that is assembled from these same fragments. In considering such fragment-assembly models, we can take advantage of the nearsightedness property of molecules. According to nearsightedness, their should exist some distance, r\_remote, beyond which the interactions between fragments can be viewed as arising from the electrostatic, multipole-multipole, interactions between the fragments. We will call any fragments separated by a distance greater than r\_remote as "remote fragments" and any closer than this distance as "nearby fragments". 

The fact that interactions between remote fragments are simply electrostatic interactions has two consequence:

- The electrostatic field applied to a fragment from remote fragments polarizes the fragment and so changes its charge distribution
- Once the polarized charge distributions of the fragments are known, the energy of interaction between remote fragments can be easily calculated. 

Predicting properties of molecules therefore requires that we know

1. The energy (and other local properties) of the fragments and their interactions with nearby fragments
2. charge distribution of the fragments in the electrostatic field applied by remote fragments. 

If the model gets the charge distribution correct, then the remote interactions will be correct. (We are, at this point, choosing to ignore dispersion, and so we will be training a dispersionless model to data computed from a high-level dispersionless ab initio method. The assumption is that we will be able to add dispersion in further model development.)

# General Approach

Our approach is that of computational experiments were we:

- Select a set of molecules over which molecular similarity can be reasonably assumed to hold.
- Generate a set of high-level (HL) data for those molecules
- Try to develop a low-cost model that reproduces the HL data

# Embedded Parameters Model

A model form that we have been playing with puts (or embeds) parameters into a low-level (LL) model, creating a parameterized low-level (pLL) model.  To date, the models have been

- LL: Hartree-Fock theory in a minimal basis, meaning each H gets a single 1s basis function and each heavy atom (C..F) gets 1s, 2s, 2px, 2py and 2pz functions
- HL: Hartree-Fock theory in a large basis set. A large basis places many more functions on each atom. We are typically using 6-31G**. (See http://en.wikipedia.org/wiki/Basis_set_%28chemistry%29 for information on basis sets.)
- pLL: The integrals of the LL model are multiplied by scaling factors, where the scaling factors depend on the model parameters and the properties of the atoms involved in the integral. 

# Hartree-Fock theory in a basis set

This section is not that well written. It assumes you've read about Hartree-Fock theory somewhere else, and summarizes things so that the notation we use for Hartree-Fock is more clear.

The Schroedinger equation for motion of a single electron, in a basis set, can be written as a linear-algebra eigenvalue problem:

H psi = E S psi

- H is a nbasis x nbasis matrix. The elements of this matrix are called Hamiltonian matrix elements, or integrals (because evaluating the matrix elements involves doing an integral)
- S is a nbasis x nbasis matrix of "overlap" matrix elements or overlap integrals.
- psi is a vector of length nbasis (an eigenvector) expressing the electron wavefunction (or orbital) in the basis set (see http://en.wikipedia.org/wiki/Linear_combination_of_atomic_orbitals)
- E is the energy of the orbital (the eigenvalue)

H psi = E S psi has nbasis solutions, meaning you get out as many molecular orbitals as there are atomic orbitals in the basis set.

The Hamiltonian consists of a sum of operators representing the various contributions to the energy (e.g. kinetic energy, potential energy) and each of these has its own matrix. For a hydrogen atom, which has just 1 electron, H = KE + Hen, where KE is the kinetic energy of the electron and Hen is the potential energy for interaction of the electron with the nucleus. 

In atoms with more than one electron, Hartree-Fock theory also includes the energy of interaction between the electron and the average charge distribution resulting from the other electrons. This average charge distribution is captured by the density matrix, rho, which is another nbasis x nbasis matrix. The interaction with the other electrons is given by a matrix G that has Coulomb, J, and exchange, K, contributions:

 G(rho) = J(rho) + K(rho)
  
  where X(rho) indicates that these matrices are functions of rho. The interactions between electrons are described by two-electron integrals (ij|kl) (see http://en.wikipedia.org/wiki/Yoshimine_sort ). Because there are four indices, the number scales as Nbasis^4, so they take alot of memory. To get J and K from rho, you do the following [TODO: someone check that the 1 and 1/2 are correct for the way rho is stored in the quambo data sets].

  J(i,j) = sum_k,l  (ij|kl) rho(k,l)
  K(i,j) = -(1/2) sum_k,l  (ik|jl) rho(k,l)

  rho comes from the filled molecular orbitals by [TODO: check the 2 here versus convention in quambo data]

  rho(i,j) = sum_a  2 C(i,a) C(j,a)

  where the sum is over the filled molecular orbitals, a, the 2 takes account of there being 2 electrons in each orbital, and C(:,a) is the a^th molecular orbital.

  To get the motion of the electrons, in the presence of the nuclei and the other electrons, we first create the Fock matrix, F. F is essentially the Hamiltonian for motion of an electron in the presence of the charge density, rho, from the other electrons:

  F = KE + sum_A HenA + J(rho) + K(rho)  = H1 + J(rho) + K(rho)

  where the sum is over all atoms, A. Because F depends on rho, we have to solve this self-consistently, meaning we iterate:

  1. start with a guess for the density matrix rho
  2. create F from rho
  3. Solve F c = eorb S c
  4. use the orbitals, c, to get a new guess at the density matrix
  5. if density matrix has changes more than eps from the past iteration, go to step 2, otherwise done.

  eps is the convergence criterion for deciding the change in the density matrix is sufficiently small that we can stop the iterations. 

  To get the total energy of the molecule, we start by adding up the filled orbital energies, multiplying by 2 since they are doubly occupied.

  sum_a 2 eorb_a

  however, this double counts the e-e interactions. So we instead double this and then substract the one-electron energy

  Etot = Enuc + 2 sum_a 2 eorb_a  - 2 sum_i,j (KE + sum_A) + sum_i,j rho(i,j) H1(i,j)

  Enuc is the nuc-nuc interaction energies. The last term is the one-electron energy and takes advantage of the fact that expectation value of any operator (whose matrix is O(i,j)) is given by:

  sum_i,j O(i,j) rho(i,j)


# Quambo

  QUAMBO is a method that can transform the large basis set Hartree-Fock results to minimal-basis results, with no loss in accuracy. We have created a data set for substituted ethanes, consisting of the following:

  - Results from a LL minimal basis calculation. This includes all operators (kinetic energy, H1en, two-electron integrals) and the solutions (orbital energies, orbitals, rho)
  - Results from a HL calculation transformed by QUAMBO, so that all of the operators are the same size as the LL results, and the basis functions (s, p etc) line up. 

  If we can predict the quambo matrices for any molecule, we have a LL theory that mimics the HL theory. Before diving into the predictions, we would like to know how accurate we need those predictions to be. Your first projects will explore two aspects of this:

  1. What are the effects of replacing quambo matrix elements with LL matrix elements, for all matrix elements between non-bonded atoms? (This will help let us know whether we need to work out a model for matrix elements between non-bonded atoms, or whether it is fine to leave them at their LL values.)

  2. What are the effects of adding noise to the quambo matrix elements between bonded atoms? (This relates the accuracy needed for a model that predicts quambo matrix elements from low-cost features.)


